//==============================================================================================================
//  단일 연결리스트 구현
//    1) 더미노드를 활용한 구현 방법( head, tail )
//==============================================================================================================
#include<stdio.h>
#include<malloc.h>
//==============================================================================================================
typedef struct node
{
	int data; //데이터
	node* next; //다음 노드 링크
}Node;
//==============================================================================================================
Node* head, * tail; //전역 포인터
//==============================================================================================================
// 초기화 함수
//==============================================================================================================
void Init()
{
	// 할당
	head = (Node*)malloc(sizeof(Node));
	tail = (Node*)malloc(sizeof(Node));
	head->next = tail;
	tail->next = NULL; // == tail->next=tail;
}
//==============================================================================================================
// 리스트에 삽입 연산
//==============================================================================================================
//  1) 리스트의 맨끝에 삽입
//==============================================================================================================
void push_back(int value)
{
	Node* newNode = (Node*)malloc(sizeof(Node));
	newNode->data = value;
	// 삽입될 위치: 리스트의 맨 끝의 데이터 노드
	Node* p = head;
	while (p->next != tail)
	{
		p = p->next;
	}// p : tail의 앞의 노드
	newNode->next = p->next;
	p->next = newNode;
}
//==============================================================================================================
// 출력함수 : 리스트 전체를 순회하며 모든 데이터를 출력하는 함수
//==============================================================================================================
void show()
{
	Node* p = head->next;
	while (p != tail)
	{
		printf("%d ->", p->data);
		p = p->next;
	}
	puts("");
}
//==============================================================================================================
//  2) 리스트의 맨앞에 삽입
//==============================================================================================================
void push_front(int value)
{
	Node* newNode = (Node*)malloc(sizeof(Node));
	newNode->data = value;
	newNode->next = head->next;
	head->next = newNode;
}
//==============================================================================================================
//  3) 리스트의 중간에 삽입 : 특정 노드 뒤에 새로운 노드를 삽입하자.
//==============================================================================================================
void insert(Node* Where, int value)
{
	Node* newNode = (Node*)malloc(sizeof(Node));
	newNode->data = value;
	newNode->next = Where->next;
	Where->next = newNode;
}
//==============================================================================================================
// 1) 맨앞에서 삭제 : head
//==============================================================================================================
void pop_front()
{
	if (head->next != tail)
	{
		Node* p = head->next; //삭제할 노드
		head->next = p->next;
		free(p);
	}
}
//==============================================================================================================
// 2) 맨뒤에서 삭제
//==============================================================================================================
void pop_back()
{
	Node* p, * s;
	if (head->next != tail)
	{
		p = head->next;
		s = head;
		while (p->next != tail)
		{
			s = p;
			p = p->next;
		}
		s->next = p->next;
		free(p);
	}
}
//==============================================================================================================
// 3) 중간에서 삭제
//==============================================================================================================
void erase(Node* Where)
{
	Node* p = head;
	while (p->next != Where)
	{
		p = p->next;
	}
	p->next = Where->next;
	free(Where);
}

//==============================================================================================================
// 검색 함수 : int값으로 노드의 포인터를 리턴
//==============================================================================================================
Node* find(int value)
{
	Node* p = head->next;
	while (p != tail)
	{
		if (p->data == value)
			return p;

	}
}


void main()
{
	Init(); //리스트 초기화
	push_back(10);
	push_back(20);
	push_back(30);
	show();
	push_front(40);
	push_front(50);
	push_front(60);
	show();
	insert(head->next->next->next, 1000);
	show();
	pop_front();
	show();
	pop_back();
	show();
}





